---
description: Worker役としてTASKを実行
argument-hint: PROJECT_NAME TASK_ID [--script]
---

> **DB中心アーキテクチャ対応**: タスク状態更新はDBスクリプト経由で実行されます。

Workerとして指定されたプロジェクトの TASK を実行します。

**引数**:
- 第1引数: プロジェクト名（例: AI_PM_PJ）
- 第2引数: TASK_ID（例: 068, 075_INT, 075_INT_02）
  - 通常タスク: 3桁数字（例: 068）
  - 割り込みタスク: `{3桁数字}_INT[_{連番2桁}]` 形式（例: 075_INT, 075_INT_02）
- オプション:
  - `--script` - スクリプトモード（1コマンドで全処理を実行）

引数が提供された場合、以下のように解析してください：
- `$ARGUMENTS` をスペースで分割し、第1引数を `PROJECT_NAME`、第2引数を `TASK_ID` として使用
- 引数が1つのみの場合: エラーメッセージ「エラー: プロジェクト名とTASK_IDを指定してください。使い方: /aipm-worker PROJECT_NAME TASK_ID」を表示
- 引数が0の場合: エラーメッセージ「エラー: プロジェクト名とTASK_IDを指定してください。使い方: /aipm-worker PROJECT_NAME TASK_ID」を表示

---

## スクリプトモード（--script）: 1コマンドで全処理を実行

`--script` オプションを指定すると、親スクリプトを使用して1コマンドでWorker処理全体を実行します。

**使用方法**:
```bash
# 通常のスクリプトモード
python backend/worker/execute_task.py $PROJECT_NAME TASK_$TASK_ID

# ドライラン（実行計画のみ表示）
python backend/worker/execute_task.py $PROJECT_NAME TASK_$TASK_ID --dry-run

# 詳細ログ出力
python backend/worker/execute_task.py $PROJECT_NAME TASK_$TASK_ID --verbose

# モデル指定（タスク推奨モデルを上書き）
python backend/worker/execute_task.py $PROJECT_NAME TASK_$TASK_ID --model opus
```

**スクリプトモードの内部処理**:
1. タスク情報取得（DB + TASKファイル）
2. Worker割当・ステータス更新（IN_PROGRESS）
3. claude -p でタスク実行
4. REPORT作成
5. ステータス更新（DONE）
6. 自動レビュー実行 → COMPLETED（※デフォルト有効、--no-reviewで無効化可）

**重要**: Worker完了時に自動レビューを実行し、COMPLETEDまで進めます。
これにより後続のBLOCKEDタスクが自動解除されます。

**メリット**:
- ツール呼び出し回数: 5-10回/処理 → 1回
- フロー漏れリスク: なし（Python保証）
- トークン消費: 50-70%削減

**--script 指定時の実行フロー**:
```
IF --script オプションあり THEN
    python backend/worker/execute_task.py $PROJECT_NAME TASK_$TASK_ID を実行
    スクリプト出力を表示
    処理終了
ELSE
    従来のステップ別処理を実行（下記参照）
END IF
```

---

以下の手順を実行してください：

---

## Step 0: データソース判定（DB中心アーキテクチャ対応）

データ取得先を判定し、DB優先でタスク・プロジェクト状態を取得します。

### 0.1 DB利用可能判定

以下の条件を順に確認：

```
DB利用可能判定:
1. backend/ ディレクトリが存在するか確認
2. data/aipm.db ファイルが存在するか確認
3. 両方存在 → DBモード
4. いずれか存在しない → 従来方式（Markdown直接読み込み）
```

### 0.2 データソースインジケータ表示（オプション）

データ取得元を表示する場合のフォーマット：

```
【データソース】
- モード: DB優先
- DB: ✓ (data/aipm.db)
- スクリプト: ✓ (backend/)
```

または（フォールバック時）:

```
【データソース】
- モード: Markdown直接読み込み
- 理由: DBスクリプトが利用不可
```

### 0.3 フォールバック条件

以下の場合は従来方式にフォールバック：

```
フォールバック条件:
1. backend/ が存在しない
2. data/aipm.db が存在しない
3. DBスクリプトがエラーで終了（exit code != 0）
4. DBスクリプトの出力が空またはパースエラー

フォールバック時の動作:
→ 従来通り Glob → Read で TASKファイルを読み込み
→ Step 1 の処理に進む（状態管理はDBスクリプト経由のみ）
```

---

## 1. TASK読み込み

### 1.0 DBモードでのタスク取得

DBが利用可能な場合（Step 0でDBモードと判定された場合）、以下のスクリプトでタスク情報を取得：

**スクリプト呼び出し**:

```bash
# タスク情報を取得
python backend/task/get.py $PROJECT_NAME TASK_$TASK_ID --json
```

**取得できる情報**:
- タスクID、タイトル、ステータス
- 依存タスク一覧（depends_on）
- 推奨モデル（recommended_model）
- ORDER ID（order_id）
- 担当者、開始日、完了日

**DBスクリプト成功時**:
- 取得したJSON情報をパースしてタスク定義として使用
- 追加でTASKファイル（Markdown）も読み込み、完了条件・実施内容を取得

**DBスクリプト失敗時**:
- フォールバック処理へ（1.1参照）

### 1.1 フォールバック処理（従来方式）

DBスクリプトが利用できない場合、または失敗した場合：

- `Glob` を使用してTASKファイルを検索
  - path: `PROJECTS/$PROJECT_NAME/RESULT`
  - pattern: `**/TASK_$TASK_ID.md`
- 複数候補がある場合は最新のORDER（ORDER番号が最大）を選択
- TASKファイルが見つからない場合: 「エラー: TASK_$TASK_ID.md が見つかりません。」を表示
- タスク定義と完了条件を理解する
- ORDER番号（ORDER_XXX）を抽出して保持する
- **推奨モデルを確認する**: TASKファイルの「推奨モデル」フィールドを確認し、モデル選択の参考にする

### 1.2 モデル選択ガイダンス（Worker向け）

タスク読み込み時に「推奨モデル」フィールドを確認し、以下のガイドラインに従ってください：

| モデル | 推奨用途 | コスト |
|--------|----------|--------|
| **Haiku** | ファイル探索、進捗確認、単純な検索・監視 | 低 |
| **Sonnet** | 設計レビュー、比較分析、調査タスク | 中 |
| **Opus** | コード作成、複雑な実装、重要な判断 | 高 |

#### 自律的判断の基準

Workerは推奨モデルを参考にしつつ、以下の場合は自律的に判断できます：

**推奨モデルより軽量なモデルを使用する場合**:
- タスクが予想より単純だった場合
- 例：調査タスク（Sonnet推奨）が単純なファイル検索で完了できる場合 → Haikuで実行可

**推奨モデルより高性能なモデルが必要な場合**:
- タスクが予想より複雑だった場合
- 重要な判断が必要になった場合
- 例：調査タスク（Sonnet推奨）で複雑な設計判断が必要になった場合 → Opusを使用

#### モデル変更時の記録

推奨モデルと異なるモデルを使用した場合は、REPORTに以下を記録：
```
### モデル選択
- 推奨モデル: {TASKファイルの推奨モデル}
- 使用モデル: {実際に使用したモデル}
- 変更理由: {変更した理由を簡潔に記載}
```

### 1.3 DBモードでの処理フロー例

```
DBモードでのタスク読み込みフロー:
1. python backend/task/get.py $PROJECT_NAME TASK_$TASK_ID --json を実行
2. 成功時:
   a. JSONからタスク情報（ID, タイトル, ステータス, 依存, ORDER等）を取得
   b. 追加でTASKファイル（Markdown）をReadして完了条件・実施内容を取得
   c. タスク情報を統合してStep 1.4（markdown_created確認）へ進む
3. 失敗時:
   a. フォールバック処理（1.1）を実行
   b. Glob/ReadでTASKファイルを取得
```

---

### 1.4 markdown_created確認（整合性警告）

タスク情報取得後、`markdown_created`フラグを確認し、FALSEの場合は警告を表示します。

#### 1.4.1 確認ロジック

```
markdown_created確認:
1. タスク情報のmarkdown_createdフィールドを確認
2. markdown_created = FALSE (0) の場合 → 警告表示
3. markdown_created = TRUE (1) の場合 → 警告なし、次のステップへ
```

#### 1.4.2 警告表示

`markdown_created = FALSE`の場合、以下の警告を表示：

```
【警告】タスク TASK_$TASK_ID のMarkdownファイルが作成されていない可能性があります。

markdown_created = FALSE

タスクはDBに登録されていますが、対応するMarkdownファイル（TASK_$TASK_ID.md）が
作成されていない可能性があります。

【推奨アクション】
- TASKファイルの存在を確認してください
- ファイルが存在する場合は、以下のコマンドでフラグを更新してください：
  python backend/task/update.py $PROJECT_NAME TASK_$TASK_ID --markdown-created true

作業を続行しますか？ [Y/n]
```

#### 1.4.3 ユーザー選択処理

- **Y（または Enter）**: 警告を承知の上で作業を続行
- **n**: 作業を中断し、Markdownファイルの確認を促す

#### 1.4.4 警告表示条件

以下の場合は警告をスキップ：
- DBモードでない場合（従来方式）
- markdown_createdフィールドがタスク情報に含まれていない場合（後方互換性）
- markdown_created = TRUE の場合

---

---

## 1.6. 依存関係チェック（並行実行対応）

タスク開始前に、依存タスクの完了状態を確認します。

### 1.6.1 DBモードでの依存関係チェック

DBが利用可能な場合（Step 0でDBモードと判定された場合）、以下のスクリプトで依存タスクの状態を確認：

**スクリプト呼び出し**:

```bash
# COMPLETEDタスク一覧を取得
python backend/task/list.py $PROJECT_NAME --status COMPLETED --json
```

**チェックロジック**:
1. Step 1で取得したタスク情報から依存タスク一覧（depends_on）を取得
2. 依存が空または無し → 依存なし、開始可能
3. COMPLETEDタスク一覧と照合
4. 全ての依存タスクがCOMPLETED → 開始可能
5. 1つでも未完了 → 開始不可（BLOCKED）

**DBスクリプト失敗時**: フォールバック処理（1.6.2）を実行

### 1.6.2 フォールバック処理（DBスクリプト失敗時）

DBスクリプトが利用できない、またはエラーの場合：

- TASKファイルの「依存」カラムから依存タスク一覧を取得
- 依存タスクがある場合はエラー終了（DB経由での確認が必要）

```
フォールバック時の依存チェック:
1. TASKファイルの「依存」カラム（または依存セクション）を取得
2. 依存が「-」または空 → 依存なし、開始可能
3. 依存タスクあり → エラー終了（DB経由での確認が必要なため）

エラーメッセージ:
「依存タスクの確認にはDBが必要です。DBスクリプトを修復してください。」
```

### 1.6.3 依存未完了時の処理（ブロック動作）

依存タスクが未完了の場合、以下のエラーを表示して実行をブロック:

```
【依存関係エラー】TASK_$TASK_ID を開始できません。

以下の依存タスクが未完了です：
- TASK_XXX: {ステータス}（{タイトル}）
- TASK_YYY: {ステータス}（{タイトル}）

依存タスクが完了してから再度実行してください。

【依存タスクの実行】
/aipm-worker $PROJECT_NAME XXX
```

### 1.6.4 依存チェック通過時

依存タスクが全て完了している、または依存がない場合は次のステップに進む。

---

## 1.7. Worker識別子の割当（並行実行対応）

同一ORDER内で複数のWorkerが並行実行する場合、Workerを識別するための識別子を割り当てます。

### 1.7.1 DBモードでのWorker識別子取得

DBが利用可能な場合（Step 0でDBモードと判定された場合）、以下のスクリプトでIN_PROGRESSタスクを確認：

**スクリプト呼び出し**:

```bash
# IN_PROGRESSタスク一覧を取得
python backend/task/list.py $PROJECT_NAME --status IN_PROGRESS --json
```

**割当ロジック**:
1. IN_PROGRESSタスクの担当者（assignee）を収集
2. Worker A, B, C... の使用状況を確認
3. 使用されていない最小の識別子を割当
   - Worker Aが使用中 → Worker Bを割当
   - Worker A,Bが使用中 → Worker Cを割当
   - 全て未使用 → Worker Aを割当

**DBスクリプト失敗時**: フォールバック処理（1.7.5）を実行

### 1.7.2 Worker識別子ルール

| ルール | 説明 |
|--------|------|
| W-001 | 並行実行時、各WorkerはWorker A, B, C...と識別 |
| W-002 | 識別子はタスク開始時に自動割当（A→B→C順） |
| W-003 | タスク完了後、識別子は解放（再利用可能） |

### 1.7.3 Worker識別子の取得（スクリプト経由）

**次のWorker識別子を取得**:

```bash
cd PROJECTS/$PROJECT_NAME/DEV && python -m aipm-db.worker.assign $PROJECT_NAME --next
```

**実行例**:
```bash
cd PROJECTS/AI_PM_PJ/DEV && python -m aipm-db.worker.assign AI_PM_PJ --next
# 出力: Worker A
```

**処理結果**:
- DBからIN_PROGRESSタスクの担当Workerを取得
- 使用されていない最小の識別子を返す（Worker A → B → C → ...）
- 全Worker使用中の場合はエラー

**オプション**:
- `--next`: 次のWorker識別子のみ出力
- `--json`: JSON形式で状況を出力
- `--table`: テーブル形式で状況を出力
- `--used-only`: 使用中Workerのみ表示

**Worker状況確認**:
```bash
cd PROJECTS/AI_PM_PJ/DEV && python -m aipm-db.worker.assign AI_PM_PJ --table
# 出力:
# 【Worker割当状況】プロジェクト: AI_PM_PJ
# 使用中: 1 / 26
# 使用中Worker:
#   - Worker A
# 次の割当: Worker B
```

### 1.7.4 識別子割当ロジック（スクリプト内部処理）

```
Worker識別子の決定（worker/assign.py内部）:
1. DBからIN_PROGRESSタスクの担当Workerを取得
2. Worker A〜Zの中から、使用されていない最小の識別子を返す
   - Worker Aが使用中 → Worker Bを返す
   - Worker A,Bが使用中 → Worker Cを返す
   - 全て未使用 → Worker Aを返す
3. 全Worker（A〜Z）使用中の場合はエラー
```

### 1.7.5 識別子の表示

Worker識別子はタスク開始時に表示:
```
【タスク開始】Worker B として TASK_$TASK_ID を開始します。
```

### 1.7.6 フォールバック処理（スクリプト利用不可時）

スクリプトが利用できない場合：
- worker/assign.py が存在しない
- Pythonが利用できない

**フォールバック動作**:
- デフォルトで「Worker A」を割当
- 並行実行は非対応（DBスクリプト必須）

**フォールバック時の処理フロー**:
```
Worker識別子の決定（フォールバック）:
1. スクリプトが利用不可能と判定
2. 「Worker A」をデフォルト割当
3. 警告メッセージ表示:「並行実行にはDBスクリプトが必要です」
```

---

## 1.8. タスク状態更新（タスク開始時）【DB経由】

### 1.8.1 更新範囲

Workerは **自タスクのみ** を更新します。他のタスクには触れないでください。

### 1.8.2 更新内容（DBスクリプト経由）

| カラム | 更新値 |
|--------|--------|
| ステータス | IN_PROGRESS |
| 担当 | Worker識別子（Worker A, B, C...） |
| 開始日 | 当日の日付（YYYY-MM-DD） |

**スクリプト呼び出し**:

```bash
# タスクステータスをIN_PROGRESSに更新
python PROJECTS/$PROJECT_NAME/DEV/aipm-db/task/update.py $PROJECT_NAME TASK_$TASK_ID \
  --status IN_PROGRESS \
  --assignee "Worker A" \
  --role Worker
```

または、Claude Code環境からは以下のコマンドで実行:

```bash
cd PROJECTS/$PROJECT_NAME/DEV && python -m aipm-db.task.update $PROJECT_NAME TASK_$TASK_ID \
  --status IN_PROGRESS \
  --assignee "Worker A" \
  --role Worker
```

**処理結果**:
- DBのtasksテーブルが更新される
- 状態遷移履歴がDBに記録される

### 1.8.3 フォールバック処理（DBスクリプト利用不可時）

DBスクリプトが利用できない場合：
- エラーメッセージを表示し、DBスクリプトの修復を促す
- タスクの状態更新はDB経由でのみ実行可能

---

## 1.9. 本番環境ガードレール（本番直接編集防止）

タスク実行中にファイルを編集する際、対象パスが本番環境かどうかを検出し、DEV環境での作業を促します。

### 1.9.1 対象パス検出

以下のパスは **本番環境** として検出します：

| パスパターン | 説明 | 除外条件 |
|------------|------|----------|
| `TEMPLATE/` を含む | テンプレートファイル群 | `DEV/TEMPLATE/` は除外 |
| `.claude/commands/` を含む | コマンドファイル群 | `DEV/.claude/commands/` は除外 |
| `scripts/` を含む | スクリプトファイル群 | `DEV/scripts/` は除外 |

### 1.9.2 検出ロジック

```
本番環境判定:
1. 編集対象のファイルパスを取得
2. 以下の条件をチェック:
   a. パスに「DEV/」が含まれる → 開発環境（本番ではない）→ 許可
   b. パスに「TEMPLATE/」を含み、「DEV/TEMPLATE/」を含まない → 本番環境
   c. パスに「.claude/commands/」を含み、「DEV/.claude/commands/」を含まない → 本番環境
   d. パスに「scripts/」を含み、「DEV/scripts/」を含まない → 本番環境
3. 本番環境と判定された場合 → 1.9.3 の警告表示へ
4. 本番環境でない場合 → 編集を許可（Step 2 または Step 3 へ進む）
```

### 1.9.3 検出時の警告・選択肢表示

本番環境のファイル編集を検出した場合、以下を表示：

```
【ガードレール検出】本番環境の直接編集

以下のファイルは本番環境に配置されています：
- {検出されたファイルパス}

本番環境の直接編集は禁止されています。
DEV環境で作業してください：
- 作業パス: PROJECTS/$PROJECT_NAME/DEV/

【選択肢】
A. DEV環境にコピーして作業（推奨）
   → 本番ファイルをDEV環境にコピーし、そちらで編集
B. このまま編集（非推奨・要承認）
   → 警告を承知の上で本番環境を直接編集
C. 作業を中断
   → 今回のTASK実行を中断

どちらを選択しますか？
```

### 1.9.4 選択肢A: DEV環境コピー機能

選択肢Aを選択した場合、以下の処理を実行：

#### コピー先パス対応表

| 本番パス | DEV環境パス |
|---------|------------|
| `TEMPLATE/xxx` | `PROJECTS/$PROJECT_NAME/DEV/TEMPLATE/xxx` |
| `.claude/commands/xxx` | `PROJECTS/$PROJECT_NAME/DEV/.claude/commands/xxx` |
| `scripts/xxx` | `PROJECTS/$PROJECT_NAME/DEV/scripts/xxx` |

#### 処理フロー

```
DEV環境コピー処理:
1. 本番ファイルのパスから対応するDEV環境パスを算出
2. コピー先ディレクトリが存在しない場合は作成
3. 本番ファイルをDEV環境にコピー（Read/Write ツールを使用）
4. 以下のメッセージを表示:

   【DEV環境コピー完了】
   本番ファイルをDEV環境にコピーしました。

   コピー元: {本番ファイルパス}
   コピー先: {DEV環境ファイルパス}

   DEV環境のファイルで作業を続行します。

5. DEV環境のファイルで編集作業を継続
```

### 1.9.5 選択肢B: 直接編集承認機能

選択肢Bを選択した場合、以下の処理を実行：

```
直接編集承認処理:
1. 以下の警告を表示:

   【警告】本番環境の直接編集を承認しました。
   この編集は本番環境に直接反映されます。
   REPORTには「本番直接編集」として記録されます。

2. 編集を許可し、作業を継続
3. REPORT作成時（Step 5）に「本番直接編集」セクションを追加:

   ### 本番直接編集

   | 項目 | 内容 |
   |------|------|
   | 対象ファイル | {編集したファイルパス} |
   | 日時 | {編集日時} |
   | 備考 | ユーザー承認済み |
```

### 1.9.6 選択肢C: 作業中断

選択肢Cを選択した場合、以下のメッセージを表示してタスクを中断：

```
【中断】本番環境の編集を中止し、TASK_$TASK_ID の実行を中断しました。

DEV環境で作業する場合は、以下の手順でセットアップしてください：
1. PROJECTS/$PROJECT_NAME/DEV/ ディレクトリを作成
2. 必要なファイルをコピー

または、タスク定義を見直してください。
```

### 1.9.7 チェックタイミング

本番環境ガードレールは以下のタイミングでチェックを実行：

```
チェックタイミング:
1. タスク開始時: TASKファイルの「実施内容」から編集対象ファイルを推測
2. ファイル編集直前: Edit/Write ツール使用時に対象パスをチェック
3. 作業途中: ユーザーから新しい編集対象の指示があった場合

※ 一度「選択肢B（直接編集承認）」を選択した場合、同一セッション内の
   同一ファイルに対する再警告はスキップ可能
```

### 1.9.8 Roamingパスガードレール（Localパス書き込み防止）

WorkerがPROJECTS/配下のファイルを読み書きする際、必ず**Roaming絶対パス**を使用してください。

#### 1.9.8.1 背景

- cwdが`AppData\Local`（インストール先）のため、相対パス`PROJECTS/...`はLocalに解決される
- Squirrelインストーラーの更新でLocalが上書きされ、永続データが消失する
- 永続データ（PROJECTS/, DB等）は必ず`AppData\Roaming`配下に配置する設計

#### 1.9.8.2 Roamingパスの取得方法

```bash
# Roaming配下のプロジェクトパスを取得
python backend/config/resolve_path.py $PROJECT_NAME --json
```

出力例:
```json
{
  "base": "C:\\Users\\...\\AppData\\Roaming\\ai-pm-manager-v2\\PROJECTS\\ai_pm_manager_v2",
  "orders": "C:\\Users\\...\\AppData\\Roaming\\ai-pm-manager-v2\\PROJECTS\\ai_pm_manager_v2\\ORDERS",
  "result": "C:\\Users\\...\\AppData\\Roaming\\ai-pm-manager-v2\\PROJECTS\\ai_pm_manager_v2\\RESULT"
}
```

#### 1.9.8.3 パスルール

| ルールID | 説明 |
|----------|------|
| RP-001 | PROJECTS/配下のファイルはRoaming絶対パスで参照する |
| RP-002 | 相対パス `PROJECTS/$PROJECT_NAME/...` は禁止（Localに解決される） |
| RP-003 | Read/Write/Editツール使用時、パスに`AppData\Local`が含まれていないか確認 |
| RP-004 | ファイルパスに`AppData\Roaming`が含まれていることを確認 |

#### 1.9.8.4 検出ロジック

```
Roamingパス検証:
1. 編集対象のファイルパスを取得
2. 以下の条件をチェック:
   a. パスに「AppData\Local」が含まれる → 警告（Localへの書き込み）
   b. パスに「AppData\Roaming」が含まれる → 許可
   c. 相対パスで「PROJECTS/」から始まる → 警告（Localに解決される可能性）
3. 警告検出時:
   → resolve_path.py で正しいRoamingパスを取得して使用
```

#### 1.9.8.5 警告表示

```
【ガードレール検出】Localパスへの書き込み

対象パス: {検出されたファイルパス}

このパスはAppData\Local配下です。Squirrelインストーラーの更新で
上書きされるため、AppData\Roaming配下に書き込んでください。

正しいパス（Roaming）:
  {Roaming版のパス}

パスを変換して作業を続行します。
```

---

## 1.10. 差し戻しタスク確認（Phase 2: PM+Worker並行稼働対応）

タスク開始前に差し戻しタスク（REWORKステータス）がある場合は優先的に通知します。

### 1.10.1 差し戻しタスク確認

DBスクリプト経由で差し戻しタスクを検索：

```bash
# 差し戻しタスクの確認（REWORKステータスのタスク）
python backend/task/list.py $PROJECT_NAME --status REWORK --json
```

```
差し戻しタスク検索:
1. DBからREWORKステータスのタスクを取得
2. 該当タスクがあれば差し戻し通知を表示
```

### 1.10.2 差し戻し通知表示

差し戻しタスクが存在する場合、タスク開始前に以下を表示：

```
【差し戻し通知】
以下のタスクがPMから差し戻されました：

- TASK_XXX: {タスク名}
  差し戻し理由: {関連REVIEW_XXX.mdを参照}

差し戻しタスクを優先的に対応しますか？ [Y/n]
```

### 1.10.3 選択肢処理

**Y（はい）を選択した場合**:
- 差し戻しタスクの実行に切り替え
- 指定されていたタスクは後回し

**n（いいえ）を選択した場合**:
- 指定タスクの実行を継続
- 差し戻しタスクは保留（ただし通知は維持）

### 1.10.4 差し戻しタスクなしの場合

差し戻しタスクがない場合は、通知なしでStep 2（ガードレールチェック）に進む。

### 1.10.5 REVIEW状態での作業許可（Phase 2変更点）

**Phase 1の動作（変更前）**:
- プロジェクト全体ステータスがREVIEWの場合、Worker作業を待機

**Phase 2の動作（変更後）**:
- プロジェクト全体ステータスがREVIEWでもWorker作業を許可
- レビュー中タスクとは別のタスクを実行可能
- 差し戻しタスクがある場合は優先通知

```
REVIEW状態判定:
1. DBからプロジェクトステータスを確認
2. ステータスがREVIEWの場合:
   - Phase 1: 「レビュー完了を待ってください」と表示し待機
   - Phase 2: 通常通りタスク実行可能（差し戻しタスク確認後）
3. レビュー中の自タスクは編集不可（競合防止ルール）
```

---

## 2. ガードレールチェック（範囲外作業検出）

タスク実行前に、現在のユーザー依頼がタスク範囲内かどうかを判定します。

### 2.1 判定基準

以下の場合は **範囲外** と判定：
- TASK定義に明記されていない新機能の追加
- 完了条件に含まれない成果物の作成
- TASKで指定されていないファイル・モジュールへの大幅な修正
- TASKの目的と関係のない追加要件

以下の場合は **範囲内** と判定：
- TASK定義の実施内容に沿った実装
- 完了条件を達成するための合理的な実装方法の選択
- 実装に伴う軽微なバグ修正・リファクタリング
- ドキュメント内容の具体化・詳細化

### 2.2 判定結果に応じた処理

**範囲内の場合**: Step 3（タスク実行）に進む

**範囲外の可能性がある場合**: 以下を表示して選択を促す

```
【ガードレール検出】範囲外作業の可能性

現在のTASK_$TASK_ID の定義:
- 実施内容: {TASK定義の内容を要約}
- 完了条件: {完了条件を列挙}

検出理由:
- {範囲外と判定した具体的な理由}

【選択肢】
A. PM役として要件追加・タスク発行（推奨）
   → 正式な手続きで追加要件をORDER/TASKに反映
B. このまま作業（非推奨）
   → 範囲外であることを承知で作業を続行
C. 作業を中断
   → 今回のTASK実行を中断

どちらを選択しますか？
```

### 2.3 選択肢Aの処理（PM役切り替え）

1. **要件追加プロセス開始**:
   - 追加要件の内容をユーザーに確認
   - ORDER_XXXのREQUIREMENTS.mdに追加要件セクションを追加

2. **割り込みタスク発行**:
   - TASK_ID採番: `TASK_{元TASK番号}_INT[_{連番}]` 形式
   - 既存の割り込みタスクを検索:
     - パターン: `TASK_{元TASK番号}_INT*`
     - 0件 → `TASK_XXX_INT`
     - N件 → `TASK_XXX_INT_{N+1:02d}`
   - 新規 `TASK_{割り込みID}.md` を `04_QUEUE/` に作成

3. **関連ファイル更新**:
   - REQUIREMENTS.md: 追加機能セクション追加
   - GOAL.md: 成功基準に追記（必要に応じて）

4. **完了メッセージ表示**:
   ```
   【割り込みタスク発行完了】
   TASK_$INTERRUPT_TASK_ID を発行しました。

   パス: PROJECTS/$PROJECT_NAME/RESULT/ORDER_XXX/04_QUEUE/TASK_$INTERRUPT_TASK_ID.md

   【次のアクション】
   割り込みタスクを実行してください:
   /aipm-worker $PROJECT_NAME $INTERRUPT_TASK_ID
   ```

### 2.4 選択肢Bの処理（そのまま作業）

以下の警告を表示してからStep 3に進む:
```
【警告】範囲外作業として続行します。
この作業はTASK定義の範囲外ですが、ユーザーの指示により続行します。
REPORTには「範囲外作業」として記録されます。
```

### 2.5 選択肢Cの処理（中断）

```
【中断】TASK_$TASK_ID の実行を中断しました。
必要に応じて、PMとしてタスク定義を見直してください。
```

---

## 3. タスク実行
- タスクに記載された実施内容を実行
- 必要に応じてファイルを作成・編集
- 作業中の進捗は TASK_$TASK_ID.md の「作業ノート」セクションに記入
- **作業途中で範囲外の追加依頼があった場合**: Step 2のガードレールチェックを再実行
- **チェックポイント記録**: 主要な作業完了時にDBにチェックポイントを記録（3.5参照）
- **バグ修正タスクの場合**: 横展開チェックを実施（3.1参照）

---

## 3.1. バグ修正時の横展開チェック（必須）

バグ修正タスクの場合、以下の横展開チェックを**必ず**実行してください。
横展開漏れは品質問題の主要因であり、レビュー時に確認されます。

### 3.1.1 横展開チェック対象の判定

以下の**いずれか**に該当する場合、横展開チェックが必要です：

| 判定条件 | 例 |
|---------|-----|
| タスクカテゴリが「バグ修正」「不具合対応」 | BACKLOG説明に「バグ」「修正」を含む |
| 修正内容がパターン化可能 | 同様のコードが他にも存在する可能性 |
| 関数名・変数名の変更を伴う修正 | リネーム、API変更など |
| 共通ロジックの修正 | ユーティリティ関数、共有モジュール |
| 複数ファイルで使用されるパターンの修正 | 類似の処理パターンが散在 |

**判定不要な場合**:
- 新規機能の追加（既存パターンなし）
- ドキュメントのみの修正
- UIの見た目調整（ロジック変更なし）

### 3.1.2 横展開チェック手順

#### Step 1: 原因パターンの特定

バグの原因となったコードパターンを明確化します。

```
原因パターン特定の例:
- 問題: order_exists() が複合キー未対応
- パターン: `xxx_exists(project_name, xxx_id)` 形式の関数
- 検索キーワード: "_exists", "project_name", "xxx_id"
```

#### Step 2: 類似パターンの検索

Grep/Glob ツールを使用して類似パターンを検索します。

```bash
# 類似関数の検索例
grep -r "def .*_exists" scripts/
grep -r "similar_pattern" --include="*.py"

# 特定の引数パターン検索
grep -r "project_name.*_id" backend/

# 関数呼び出し箇所の検索
grep -r "order_exists\|task_exists\|backlog_exists" scripts/
```

**検索のコツ**:
- 関数名の一部（`_exists`, `_create`, `_update`）で検索
- 引数パターンで検索
- エラーメッセージの類似パターンで検索

#### Step 3: 横展開リストの作成

検出された類似箇所をリスト化し、同様の問題有無を確認します。

```markdown
| # | ファイル | 関数/箇所 | 同様の問題 | 対応 |
|---|---------|----------|----------|------|
| 1 | utils/validation.py | order_exists() | あり（修正対象） | 修正済み |
| 2 | utils/validation.py | task_exists() | あり（修正対象） | 修正済み |
| 3 | utils/validation.py | backlog_exists() | あり（見落とし） | 要修正 |
| 4 | order/create.py | check_order() | なし | - |
```

#### Step 4: 横展開修正の実施

同様の問題がある箇所をすべて修正します。

```
横展開修正のチェックリスト:
1. [ ] 検出された全箇所を確認
2. [ ] 同様の問題がある箇所をリストアップ
3. [ ] 各箇所の修正を実施
4. [ ] 修正後の動作確認
5. [ ] 修正漏れがないことを再確認（再検索）
```

#### Step 5: REPORT記載

横展開チェック結果を REPORT_XXX.md の「横展開チェック結果」セクションに記載します。

```markdown
## 横展開チェック結果

### 原因パターン
- `xxx_exists(project_name, xxx_id)` 関数の複合キー未対応

### 検索コマンド
```bash
grep -r "def .*_exists" backend/
```

### 横展開リスト
| # | ファイル | 関数/箇所 | 同様の問題 | 対応状況 |
|---|---------|----------|----------|---------|
| 1 | validation.py | order_exists() | あり | 修正済み |
| 2 | validation.py | task_exists() | あり | 修正済み |
| 3 | validation.py | backlog_exists() | あり | 修正済み |

### 横展開確認結果
- [x] 全類似箇所を確認済み
- [x] 横展開修正を実施済み
```

### 3.1.3 横展開チェックの省略

以下の場合は横展開チェックを省略できます：

| 条件 | 記載内容 |
|------|---------|
| 新規機能追加タスク | 「新規機能のため横展開対象なし」 |
| ドキュメント修正のみ | 「ドキュメント修正のため横展開対象なし」 |
| 一意な処理の修正 | 「検索の結果、類似パターンなし」 |

省略する場合も、REPORTに省略理由を記載してください。

### 3.1.4 横展開漏れ防止のポイント

```
横展開漏れ防止チェックリスト:
1. 検索は複数パターンで実施（関数名、引数名、処理パターン）
2. 検索結果は全件確認（一部のみの確認は危険）
3. 「なし」と判断する場合も、検索コマンドと結果を記録
4. 修正後に再検索して漏れがないことを確認
5. 不明な場合は類似と判断して確認対象に含める
```

---

## 3.5. チェックポイント記録（進捗記録・リカバリ対応）【スクリプト経由】

タスク実行中、主要なステップ完了時にチェックポイントを記録します。

### 3.5.1 記録トリガー

以下のタイミングでチェックポイントを記録：

| トリガーID | トリガー名 | 発火条件 | 自動/手動 |
|-----------|----------|---------|---------|
| CP-T01 | ファイル作成完了 | Write/Editツールで成果物ファイル作成後 | 自動 |
| CP-T02 | ファイル編集完了 | Editツールで主要ファイル編集後 | 自動 |
| CP-T03 | サブタスク完了 | TodoWriteで項目をcompleted更新時 | 自動 |
| CP-T04 | 重要判断完了 | 設計決定、方針確定後 | 手動 |
| CP-T05 | マイルストーン到達 | 完了条件の一部達成時 | 手動 |

### 3.5.2 チェックポイント記録（スクリプト経由）

**スクリプト呼び出し**:

```bash
cd PROJECTS/$PROJECT_NAME/DEV && python -m aipm-db.session.checkpoint $PROJECT_NAME --step "ステップ名" --next "次のアクション" --memo "メモ"
```

**実行例**:
```bash
cd PROJECTS/AI_PM_PJ/DEV && python -m aipm-db.session.checkpoint AI_PM_PJ --step "aipm-worker.md編集完了" --next "テスト実施" --memo "Step 1.5, 3.5更新"
```

**処理結果**:
- DBのチェックポイントテーブルに新しい行を追記
- タイムスタンプは自動生成（YYYY-MM-DD HH:MM形式）

**オプション**:
- `--step, -s`: 完了したステップ名（必須）
- `--next, -n`: 次のアクション（省略時は"-"）
- `--memo, -m`: メモ（省略時は"-"）
- `--json`: JSON形式で結果出力

### 3.5.3 チェックポイント記録フォーマット

DBのチェックポイントテーブルに以下の形式で追記：

```markdown
| 時刻 | ステップ | 次のアクション | メモ |
|------|---------|---------------|------|
| 2026-01-21 14:30 | {完了したステップ名} | {次に実行する作業} | {補足情報} |
```

### 3.5.4 記録例

**ファイル作成完了時（CP-T01）**:
```bash
python -m aipm-db.session.checkpoint AI_PM_PJ --step "checkpoint_design.md作成完了" --next "次ステップ実行" --memo "設計書v1.0"
```

**重要判断完了時（CP-T04）**:
```bash
python -m aipm-db.session.checkpoint AI_PM_PJ --step "記録方式決定" --next "設計書作成" --memo "履歴保持方式を採用"
```

**マイルストーン到達時（CP-T05）**:
```bash
python -m aipm-db.session.checkpoint AI_PM_PJ --step "完了条件1達成" --next "次の条件" --memo "3種類のトリガー定義完了"
```

### 3.5.5 記録スキップ条件

以下の場合はチェックポイント記録をスキップ（後方互換性）：
- 軽微な編集（typo修正、コメント追加など）の場合

### 3.5.6 フォールバック処理（スクリプト利用不可時）

スクリプトが利用できない場合（後方互換性）：
- session/checkpoint.py が存在しない
- Pythonが利用できない

**フォールバック動作**:
チェックポイント記録をスキップし、警告を表示します。

---

## 3.6. エラー発生時処理（INTERRUPTED遷移）

タスク実行中にエラーが発生した場合、適切に状態を記録してINTERRUPTED状態に遷移します。

### 3.6.1 エラー検出タイミング

| エラー種別 | 検出方法 | 対応 |
|-----------|---------|------|
| `SESSION_DISCONNECT` | セッション切断検出 | 自動記録（可能な場合） |
| `CLAUDE_ERROR` | Claude APIエラー | 自動記録 |
| `USER_INTERRUPT` | ユーザーによる中断 | 手動トリガー |
| `RESOURCE_ERROR` | ファイル/ネットワークエラー | 自動記録 |
| `VALIDATION_ERROR` | 検証エラー | 自動記録 |
| `UNKNOWN` | その他/不明 | 手動トリガー |

### 3.6.2 エラー発生時の処理フロー

```
エラー発生時処理:
1. エラーを検出
2. DBにエラーログを記録（スクリプト経由）:
   - 発生日時
   - エラー種別
   - 発生タスク
   - 発生ステップ（現在の作業内容）
   - 最終チェックポイント
   - エラーメッセージ（取得可能な場合）
3. DBステータスを更新（スクリプト経由）:
   - タスクステータス: IN_PROGRESS → INTERRUPTED
4. 以下のメッセージを表示（可能な場合）:

   【エラー発生】タスクが中断されました。

   エラー種別: {種別}
   発生タスク: TASK_$TASK_ID
   最終チェックポイント: {最終CP}

   リカバリするには:
   /aipm-recover $PROJECT_NAME
```

### 3.6.3 エラーログ記録フォーマット

```markdown
| 発生日時 | 種別 | タスク | ステップ | 最終CP | メッセージ |
|---------|------|--------|---------|--------|----------|
| 2026-01-21 15:45 | SESSION_DISCONNECT | TASK_178 | 設計書作成中 | ファイル作成完了 | ネットワーク切断 |
```

### 3.6.4 タスク状態更新（INTERRUPTED遷移）

```bash
# タスクをINTERRUPTED状態に更新
python backend/task/update.py $PROJECT_NAME TASK_$TASK_ID --status INTERRUPTED
```

```
DB更新内容:
1. タスクステータス: IN_PROGRESS → INTERRUPTED
2. 状態遷移履歴に記録
```

### 3.6.5 手動中断トリガー

ユーザーが明示的にタスクを中断する場合、以下の手順で処理：

```
ユーザー: タスクを中断して
Worker:
【タスク中断】TASK_$TASK_ID を中断します。

中断理由を選択してください:
A. 一時停止（後で再開予定）
B. 情報不足（追加情報待ち）
C. 別タスク優先
D. その他

User: A
Worker:
【中断処理完了】
- チェックポイントをDBに記録
- タスクステータスをINTERRUPTEDに更新（DB経由）

リカバリするには:
/aipm-recover $PROJECT_NAME
```

---

## 3.7. INTERRUPTED状態からの再開

INTERRUPTED状態のタスクを再開する場合の処理を定義します。

### 3.7.1 再開条件

タスクがINTERRUPTED状態からの再開である場合、以下を確認：
- DBにチェックポイント履歴がある
- 最終チェックポイントが特定できる

### 3.7.2 再開時の処理フロー

```
INTERRUPTED状態からの再開:
1. DBからチェックポイント履歴を取得
2. チェックポイント履歴を確認
3. 最終チェックポイントを表示:

   【タスク再開】TASK_$TASK_ID をINTERRUPTED状態から再開します。

   最終チェックポイント:
   - ステップ: {最終CPのステップ名}
   - 時刻: {最終CPの時刻}
   - 次のアクション: {最終CPの次のアクション}

   エラーログ（あれば）:
   - 種別: {エラー種別}
   - 発生ステップ: {発生ステップ}

4. DBを更新（スクリプト経由）:
   - ステータス: INTERRUPTED → IN_PROGRESS
5. 「次のアクション」から作業を再開
```

### 3.7.3 再開メッセージ表示

```
【タスク再開】Worker A として TASK_$TASK_ID を再開します。

前回の状態:
- 最終チェックポイント: {ステップ名}（{時刻}）
- 中断理由: {エラー種別}

次のアクション: {最終CPの次のアクション}

作業を再開します。
```

### 3.7.4 再開時のDB更新

```
DB更新内容:
1. ステータス: INTERRUPTED → IN_PROGRESS
2. 更新履歴に再開記録を追加
```

---

## 4. 成果物配置
- 作成したファイルを `PROJECTS/$PROJECT_NAME/RESULT/ORDER_XXX/06_ARTIFACTS/` に配置
- または、指定された場所に配置

---

## 5. REPORT作成
- `PROJECTS/$PROJECT_NAME/RESULT/ORDER_XXX/05_REPORT/REPORT_$TASK_ID.md` を作成
- 実施内容、成果物、完了条件チェックを記載
- 問題があればエスカレーション事項を記載
- **範囲外作業を行った場合**: 「範囲外作業」セクションを追加し、理由と内容を記録
- **本番直接編集を行った場合**: 「本番直接編集」セクションを追加（1.9.5参照）

---

## 6. TASK完了報告記入
- TASK_$TASK_ID.md の「完了報告」セクションを記入
- 完了条件をすべてチェック

---

## 6.5. 完了サマリ生成・記録（Worker完了時の情報整理）

タスク完了時、レビュー用サマリを自動生成し、DBに記録します。

### 6.5.1 完了サマリの生成

タスク完了報告記入後、以下のフォーマットで完了サマリを生成：

```
【Worker完了サマリ】
Task ID: TASK_$TASK_ID
タスク名: {TASKファイルのタスク名}

実施内容:
- {実施した内容1（3行以内で要約）}
- {実施した内容2}
- {実施した内容3}

主要成果物:
- {成果物1}（{パスまたは説明}）
- {成果物2}（{パスまたは説明}）

判断のポイント:
- {重要な判断事項があれば記載}
- {代替案の検討結果など}

未解決課題:
- {あれば記載、なければ「なし」}

次のアクション推奨:
- {後続タスクへの情報や推奨事項}
```

### 6.5.2 サマリの記録先

生成したサマリは以下に記録します：

| 記録先 | 記録内容 |
|--------|----------|
| DB（更新履歴テーブル） | サマリの要約版（自動記録） |
| REPORT_$TASK_ID.md | サマリ全文（「完了サマリ」セクション） |

### 6.5.3 更新履歴への追加【DB経由・自動記録】

> **Note**: DB中心アーキテクチャでは、更新履歴はDBに自動記録されます。

**スクリプト呼び出し時の自動記録**:
- `task/update.py` 呼び出し時、変更履歴がDBに記録される

```
更新履歴への追加フォーマット:
| {日付} | Worker {識別子} | TASK_$TASK_ID完了：{タスク名}（{実施内容要約}）、{主要成果物}作成 |
```

**例**:
```markdown
| 2026-01-20 | Worker A | TASK_167完了：aipm-worker.md完了サマリ出力強化（Step 6.5追加、DB更新ロジック追加）、DEV環境コマンド更新 |
```

### 6.5.4 DB更新（完了状態への遷移）

タスク完了時、DBを以下のように更新：

```
DB更新内容:
1. タスクステータスを「DONE」に変更
2. 完了日時を記録
3. 更新履歴に完了記録を追加
```

### 6.5.5 サマリ生成タイミング

```
サマリ生成フロー:
1. Step 6（TASK完了報告記入）完了後
2. 完了サマリを生成
3. REPORT_$TASK_ID.mdに「完了サマリ」セクション追加
4. DB更新履歴に追加（自動記録）
5. Step 6.6（タスクステータスDONE更新）へ進む
```

### 6.5.6 サマリ生成が不要な場合

以下の場合はサマリ生成をスキップ可能（後方互換性）：
- REPORT作成時に「完了サマリ」セクションは必須（スキップ不可）

---

## 6.6. タスクステータスDONE更新（**必須** - スキップ不可）【DB経由】

> **重要**: このステップは**必須**です。スキップ不可。
> ステータスがDONEに更新されていないタスクは「完了」とみなされません。

タスク完了時、DBのタスクステータスを**必ず**DONEに更新します。

### 6.6.1 タスクステータス更新手順（DBスクリプト経由）【必須】

タスク完了報告記入後、以下のスクリプトでタスクステータスを**必ず**更新：

**スクリプト呼び出し**:

```bash
# タスクステータスをDONEに更新
python backend/task/update.py $PROJECT_NAME TASK_$TASK_ID --status DONE
```

**処理結果**:
- タスクステータスが「DONE」に更新される
- 状態遷移履歴がDBに記録される

### 6.6.2 DB更新例（スクリプト実行後）

**スクリプト実行**:
```bash
python backend/task/update.py AI_PM_PJ TASK_143 --status DONE --json
```

**DB更新結果**:
- タスクステータス: DONE

### 6.6.3 エラー処理（DBスクリプトが利用できない場合）【必須対応】

**DBスクリプトが利用できない場合**：
- backendディレクトリが存在しない
- データベースが初期化されていない
- スクリプト実行エラー

**エラー時の動作**（スキップ不可）:
1. **タスク完了を保留**（ステータスDONE更新なしに完了とみなさない）
2. エラーメッセージを表示
3. DBスクリプトの修復を促す
4. **タスクステータスはIN_PROGRESSのまま維持**

**エラーメッセージ**：
```
【エラー】タスクステータス更新に失敗しました。

DBスクリプトが利用できないため、タスク完了処理を保留します。
タスクステータス: IN_PROGRESS（変更なし）

■ 必要なアクション
1. DBスクリプトを修復してください
2. 修復後、再度タスク完了処理を実行してください
   /aipm-worker $PROJECT_NAME $TASK_ID

ステータスDONE更新なしにタスクは「完了」とみなされません。
```

---

## 7. 最終回答
- REPORTファイルパスを返答:
  `PROJECTS/$PROJECT_NAME/RESULT/ORDER_XXX/05_REPORT/REPORT_$TASK_ID.md`
- PMレビューを促すメッセージを追加:
  ```
  【作業完了】TASK_$TASK_ID を完了しました。

  REPORT_$TASK_ID.md を作成しました。
  パス: PROJECTS/$PROJECT_NAME/RESULT/ORDER_XXX/05_REPORT/REPORT_$TASK_ID.md

  【次のアクション】
  PMレビューを実施してください：
  /aipm-review $PROJECT_NAME $TASK_ID
  ```

---

## 実行例

### 1. 通常タスクの実行
```
/aipm-worker AI_PM_PJ 068
```
→ AI_PM_PJ プロジェクトの TASK_068.md を読み込み、タスクを実行して REPORT_068.md を作成し、PMレビューを促す

### 2. 割り込みタスクの実行
```
/aipm-worker AI_PM_PJ 075_INT
```
→ AI_PM_PJ プロジェクトの TASK_075_INT.md を読み込み、割り込みタスクを実行して REPORT_075_INT.md を作成

### 3. 複数回割り込みタスクの実行
```
/aipm-worker AI_PM_PJ 075_INT_02
```
→ AI_PM_PJ プロジェクトの TASK_075_INT_02.md を読み込み、2回目の割り込みタスクを実行

### 4. ガードレール検出時の例
```
User: TASK_075を実行して、ついでに認証機能も追加して
Worker:
【ガードレール検出】範囲外作業の可能性

現在のTASK_075 の定義:
- 実施内容: バックログ管理・割り込みタスクの設計
- 完了条件: 設計書作成、命名規則定義

検出理由:
- 「認証機能の追加」はTASK_075の完了条件に含まれていません

【選択肢】
A. PM役として要件追加・タスク発行（推奨）
B. このまま作業（非推奨）
C. 作業を中断

どちらを選択しますか？
```

### 5. 依存関係エラーの例
```
/aipm-worker AI_PM_PJ 112
Worker:
【依存関係エラー】TASK_112 を開始できません。

以下の依存タスクが未完了です：
- TASK_108: IN_PROGRESS（現状分析・並行実行設計）

依存タスクが完了してから再度実行してください。

【依存タスクの実行】
/aipm-worker AI_PM_PJ 108
```
→ 依存タスクTASK_108が未完了のため、TASK_112の実行がブロックされる

### 6. 並行実行時の例
```
# ターミナル1（Worker A）
/aipm-worker AI_PM_PJ 110
Worker:
【タスク開始】Worker A として TASK_110 を開始します。

# ターミナル2（Worker B）
/aipm-worker AI_PM_PJ 111
Worker:
【タスク開始】Worker B として TASK_111 を開始します。
```
→ 同一ORDER内でTASK_110とTASK_111が並行実行される

### 7. 本番環境ガードレール検出時の例
```
User: TASK_120を実行して、aipm-worker.mdを編集してね
Worker:
【ガードレール検出】本番環境の直接編集

以下のファイルは本番環境に配置されています：
- .claude/commands/aipm-worker.md

本番環境の直接編集は禁止されています。
DEV環境で作業してください：
- 作業パス: PROJECTS/AI_PM_PJ/DEV/

【選択肢】
A. DEV環境にコピーして作業（推奨）
   → 本番ファイルをDEV環境にコピーし、そちらで編集
B. このまま編集（非推奨・要承認）
   → 警告を承知の上で本番環境を直接編集
C. 作業を中断
   → 今回のTASK実行を中断

どちらを選択しますか？
```
→ 本番環境（.claude/commands/）のファイル編集を検出し、DEV環境での作業を促す

### 8. DEV環境コピー完了の例
```
User: A（DEV環境にコピーして作業）
Worker:
【DEV環境コピー完了】
本番ファイルをDEV環境にコピーしました。

コピー元: .claude/commands/aipm-worker.md
コピー先: PROJECTS/AI_PM_PJ/DEV/.claude/commands/aipm-worker.md

DEV環境のファイルで作業を続行します。
```
→ 本番ファイルがDEV環境にコピーされ、そちらで作業を継続

### 9. 差し戻し通知の例（Phase 2）
```
/aipm-worker AI_PM_PJ 150
Worker:
【差し戻し通知】
以下のタスクがPMから差し戻されました：

- TASK_148: DB更新
  差し戻し理由: 完了条件未達（レビューキュー形式不正）

差し戻しタスクを優先的に対応しますか？ [Y/n]

User: Y
Worker:
【タスク切り替え】TASK_150 → TASK_148
差し戻しタスク TASK_148 を実行します。
```
→ 差し戻しタスクがある場合、優先的に対応するかどうかを確認

### 10. タスク完了時の完了サマリ出力例
```
/aipm-worker AI_PM_PJ 150
Worker:
【作業完了】TASK_150 を完了しました。

【Worker完了サマリ】
Task ID: TASK_150
タスク名: APIエンドポイント追加

実施内容:
- ユーザー一覧取得APIを実装
- ページネーション対応
- 単体テスト作成（カバレッジ90%）

主要成果物:
- src/api/users.ts（新規作成）
- tests/api/users.test.ts（新規作成）

判断のポイント:
- ページネーションはカーソルベースを採用（オフセットより効率的）
- 1ページあたり20件をデフォルトに設定

未解決課題:
- キャッシュ戦略は後続タスクで検討

次のアクション推奨:
- TASK_151（認証連携）でAPI認証を統合予定

DB更新:
- タスクステータス: DONE

REPORT_150.md を作成しました。
パス: PROJECTS/AI_PM_PJ/RESULT/ORDER_XXX/05_REPORT/REPORT_150.md

【次のアクション】
PMレビューを実施してください：
/aipm-review AI_PM_PJ 150
```
→ タスク完了時に完了サマリを生成し、DBを更新

### 11. REVIEW状態での作業例（Phase 2）
```
/aipm-worker AI_PM_PJ 152
Worker:
【プロジェクト状態】
- 全体ステータス: REVIEW
- レビュー中: TASK_150, TASK_151

Phase 2では、レビュー中でも別タスクの実行が可能です。

【タスク開始】Worker A として TASK_152 を開始します。
```
→ プロジェクトがREVIEW状態でも、別タスクの実行が可能

### 12. DB更新履歴への完了サマリ記録例
タスク完了時、DBの更新履歴テーブルに完了サマリが記録されます：

```
タスク: TASK_167
内容: aipm-worker.md完了サマリ出力強化（Step 6.5追加、DB更新ロジック追加）
担当: Worker A
日時: 2026-01-20
```

→ PMはDB（または/aipm-status）でWorkerの完了状況を確認できる

### 13. チェックポイント記録の例
```
/aipm-worker AI_PM_PJ 178
Worker:
【タスク開始】Worker A として TASK_178 を開始します。

... （作業中）...

【チェックポイント記録】
ステップ: aipm-worker.md編集完了
時刻: 2026-01-21 14:30
次のアクション: 実行例セクション追加

DBに記録しました。
```
→ 主要な作業完了時にチェックポイントがDBに記録される

### 14. エラー発生・INTERRUPTED遷移の例
```
/aipm-worker AI_PM_PJ 178
Worker:
【タスク開始】Worker A として TASK_178 を開始します。

... （作業中にエラー発生）...

【エラー発生】タスクが中断されました。

エラー種別: SESSION_DISCONNECT
発生タスク: TASK_178
発生ステップ: REPORT作成中
最終チェックポイント: aipm-worker.md編集完了（2026-01-21 14:30）

エラーログをDBに記録しました。
タスクステータスを INTERRUPTED に更新しました。

リカバリするには:
/aipm-recover AI_PM_PJ
```
→ エラー発生時、エラーログをDBに記録し、タスクステータスをINTERRUPTEDに更新

### 15. INTERRUPTED状態からの再開例
```
/aipm-worker AI_PM_PJ 178
Worker:
【タスク再開】Worker A として TASK_178 を再開します。

前回の状態:
- 最終チェックポイント: aipm-worker.md編集完了（2026-01-21 14:30）
- 中断理由: SESSION_DISCONNECT

エラーログ:
- 種別: SESSION_DISCONNECT
- 発生ステップ: REPORT作成中
- メッセージ: ネットワーク切断

次のアクション: 実行例セクション追加

タスクステータスを IN_PROGRESS に更新しました。
作業を再開します。
```
→ INTERRUPTED状態から再開時、最終チェックポイントの情報を表示して作業を継続

### 16. 手動中断の例
```
User: タスクを中断して
Worker:
【タスク中断】TASK_178 を中断します。

中断理由を選択してください:
A. 一時停止（後で再開予定）
B. 情報不足（追加情報待ち）
C. 別タスク優先
D. その他

User: A
Worker:
【中断処理完了】
- 最終チェックポイント: aipm-worker.md編集完了（2026-01-21 14:30）
- チェックポイントをDBに記録
- タスクステータスをINTERRUPTEDに更新

リカバリするには:
/aipm-recover AI_PM_PJ
```
→ ユーザーの指示でタスクを明示的に中断し、後でリカバリ可能な状態にする

### 17. DB方式でのタスク開始例（セッション・Worker割当対応）
```
/aipm-worker AI_PM_PJ 192
Worker:
【Worker識別子取得】
$ python -m aipm-db.worker.assign AI_PM_PJ --next
Worker A

【タスク開始】Worker A として TASK_192 を開始します。

【DBスクリプト実行】
タスクステータス更新: IN_PROGRESS
$ python -m aipm-db.task.update AI_PM_PJ TASK_192 --status IN_PROGRESS --assignee "Worker A" --role Worker

タスクを更新しました: TASK_192
  タイトル: aipm-workerコマンド更新
  ステータス: IN_PROGRESS
  担当者: Worker A

DB更新が完了しました。
```
→ タスク開始時、Worker識別子取得→タスクステータス更新の順でスクリプトを実行

### 17.1 チェックポイント記録例
```
/aipm-worker AI_PM_PJ 192
Worker:
... （作業中）...

【チェックポイント記録】
$ python -m aipm-db.session.checkpoint AI_PM_PJ --step "aipm-worker.md編集完了" --next "テスト実施" --memo "Step 1.5, 3.5, 1.7更新"
[OK] チェックポイントを記録しました: aipm-worker.md編集完了

DBに記録しました。
```
→ 作業完了時、チェックポイントをスクリプト経由でDBに記録する

### 18. DB方式でのタスク完了例
```
/aipm-worker AI_PM_PJ 192
Worker:
【作業完了】TASK_192 を完了しました。

【DBスクリプト実行】
タスクステータス更新:
$ python backend/task/update.py AI_PM_PJ TASK_192 --status DONE

DB更新が完了しました。
- タスクステータス: DONE

REPORT_192.md を作成しました。
パス: PROJECTS/AI_PM_PJ/RESULT/ORDER_036/05_REPORT/REPORT_192.md

【次のアクション】
PMレビューを実施してください：
/aipm-review AI_PM_PJ 192
```
→ タスク完了時、DBスクリプト経由でタスクステータスをDONEに更新

### 19. DB方式での差し戻し再提出例
```
/aipm-worker AI_PM_PJ 192
Worker:
【作業完了】TASK_192 を完了しました（修正完了）。

【DBスクリプト実行】
タスクステータス更新（差し戻し再提出）:
$ python backend/task/update.py AI_PM_PJ TASK_192 --status DONE

DB更新が完了しました。
- タスクステータス: DONE
```
→ 差し戻しタスクの再提出時もtask/update.pyでDONEに更新

### 20. バグ修正タスクでの横展開チェック例
```
/aipm-worker AI_PM_PJ 200
Worker:
【タスク開始】Worker A として TASK_200 を開始します。

タスク種別: バグ修正
→ 横展開チェックが必要です（Step 3.1）

【横展開チェック実施】

■ Step 1: 原因パターンの特定
- 問題: order_exists() が複合キー（project_id + order_id）未対応
- パターン: `xxx_exists(project_name, xxx_id)` 形式の関数

■ Step 2: 類似パターンの検索
$ grep -r "def .*_exists" backend/
utils/validation.py:def order_exists(...)
utils/validation.py:def task_exists(...)
utils/validation.py:def backlog_exists(...)

■ Step 3: 横展開リスト作成

| # | ファイル | 関数/箇所 | 同様の問題 | 対応 |
|---|---------|----------|----------|------|
| 1 | validation.py | order_exists() | あり | 修正済み |
| 2 | validation.py | task_exists() | あり | 修正済み |
| 3 | validation.py | backlog_exists() | あり | 修正済み |

■ Step 4: 横展開修正実施
- 3件の関数を全て複合キー対応に修正

■ Step 5: REPORT記載
- 「横展開チェック結果」セクションに結果を記載

【作業完了】TASK_200 を完了しました。

横展開チェック結果: 3件検出 → 3件修正済み

REPORT_200.md を作成しました。
```
→ バグ修正タスクでは横展開チェックを実施し、結果をREPORTに記載

### 21. 横展開チェック省略例（新規機能）
```
/aipm-worker AI_PM_PJ 201
Worker:
【タスク開始】Worker A として TASK_201 を開始します。

タスク種別: 新規機能追加
→ 横展開チェック対象外（新規機能のため）

【横展開チェック】
省略理由: 新規機能追加のため、類似パターンなし

... (タスク実行) ...

【作業完了】TASK_201 を完了しました。

REPORT記載:
- 横展開チェック結果: 「新規機能のため横展開対象なし」
```
→ 新規機能追加タスクでは横展開チェックを省略可能（理由を記載）

---

## 並行実行に関する注意事項

### 同一ORDER内での並行実行

- 複数のWorkerが同一ORDER内で同時にタスクを実行できます
- 各Workerは独立した識別子（Worker A, B, C...）を持ちます
- 依存関係のないタスクは並行実行可能です

### 競合回避ルール

| ルール | 説明 |
|--------|------|
| R-001 | タスク定義時に編集対象ファイルを明記する |
| R-002 | 同一ファイルを複数タスクで編集する場合は依存関係を設定する |
| R-003 | 共有リソースへのアクセスは依存関係で順序制御する |
| R-004 | 万が一競合した場合は手動マージ対応（Phase 1） |

### DB更新時の注意

- **自タスクのみ** を更新してください
- 他のWorkerが担当中のタスクには触れないでください
- DB更新はスクリプト経由で実行してください

### 制限事項

| 制限 | 理由 |
|------|------|
| 同時実行数の上限: 5（worker_config.py で設定） | リソース監視付きで自動スケーリング |
| 循環依存自動検出なし | PM責務として運用 |

---

## テスト・一時ファイルの出力ルール

| ルール | 説明 |
|--------|------|
| T-001 | テスト用一時ファイルは `tmp/` 配下に出力すること |
| T-002 | プロジェクトルート直下へのテストファイル作成は禁止 |
| T-003 | ORDER結果内のテスト成果物は `RESULT/ORDER_XXX/05_REPORT/` に集約 |

**出力先ディレクトリ**:
- テスト用一時ファイル: `D:\your_workspace\AI_PM\tmp/`（.gitignore対象）
- テスト結果レポート: `PROJECTS/{PROJECT}/RESULT/ORDER_XXX/05_REPORT/`

**禁止事項**:
- `tmp_*.json`、`test_*.py` 等をプロジェクトルート直下に作成しないこと
- `TASK_*_IMPLEMENTATION.md` 等の作業メモをルート直下に放置しないこと

---

## DBスクリプト利用ガイド（DB中心アーキテクチャ）

### スクリプト一覧

| スクリプト | 用途 | 呼び出しタイミング |
|-----------|------|-------------------|
| `task/update.py` | タスクステータス更新 | タスク開始時、完了時、中断時 |
| `task/get.py` | タスク情報取得 | タスク情報確認時 |
| `task/list.py` | タスク一覧取得 | 依存関係確認時 |
| `session/checkpoint.py` | チェックポイント記録 | 作業完了時（Step 3.5） |
| `worker/assign.py` | Worker識別子割当 | タスク開始時（Step 1.7） |

### 基本的な使い方

```bash
# 作業ディレクトリ移動
cd PROJECTS/$PROJECT_NAME/DEV

# タスクステータス更新
python -m aipm-db.task.update $PROJECT_NAME TASK_$TASK_ID --status IN_PROGRESS --role Worker

# タスク情報取得
python -m aipm-db.task.get $PROJECT_NAME TASK_$TASK_ID --json

# 差し戻しタスク確認（REWORKステータス）
python -m aipm-db.task.list $PROJECT_NAME --status REWORK

# チェックポイント記録
python -m aipm-db.session.checkpoint $PROJECT_NAME --step "ステップ名" --next "次のアクション" --memo "メモ"

# Worker識別子取得
python -m aipm-db.worker.assign $PROJECT_NAME --next
```

### 後方互換性

DBスクリプトが利用できない環境では、エラー終了となりDBスクリプトの修復が必要です。

```
フォールバック条件:
1. aipm-db ディレクトリが存在しない
2. データベースファイルが初期化されていない
3. Pythonが利用できない
```

この場合、DBスクリプトを修復してからタスクを再実行してください。
